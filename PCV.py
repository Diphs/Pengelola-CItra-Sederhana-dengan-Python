# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PCV.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os
from tkinter import messagebox
import cv2
import pandas as pd
from rembg import remove
import subprocess
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QMainWindow, QLabel, QVBoxLayout, QWidget, QScrollArea, QPushButton
from PyQt5.QtGui import QImage, QPixmap, QColor
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QFileDialog, QGraphicsView
from PyQt5.QtGui import QPainter, QPen, QPolygonF
from PyQt5.Qt import QGraphicsScene, QGraphicsPixmapItem, QRectF, QCursor
from PyQt5.QtCore import QPoint
import matplotlib.pyplot as plt


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(771, 978)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(10, 10, 751, 441))
        self.label.setFrameShape(QtWidgets.QFrame.Box)
        self.label.setText("")
        self.label.setScaledContents(True)
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(10, 460, 751, 441))
        self.label_2.setFrameShape(QtWidgets.QFrame.Box)
        self.label_2.setText("")
        self.label_2.setScaledContents(True)
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(10, 910, 371, 23))
        self.label_3.setFrameShape(QtWidgets.QFrame.Box)
        self.label_3.setText("")
        self.label_3.setObjectName("label_3")
        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(390, 910, 161, 23))
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 771, 21))
        self.menubar.setObjectName("menubar")
        self.menuColors = QtWidgets.QMenu(self.menubar)
        self.menuColors.setObjectName("menuColors")
        self.menuRGB_to_Grayscale = QtWidgets.QMenu(self.menuColors)
        self.menuRGB_to_Grayscale.setObjectName("menuRGB_to_Grayscale")
        self.menuBit_Depth = QtWidgets.QMenu(self.menuColors)
        self.menuBit_Depth.setObjectName("menuBit_Depth")
        self.menuGeometri = QtWidgets.QMenu(self.menubar)
        self.menuGeometri.setObjectName("menuGeometri")
        self.menuScalling = QtWidgets.QMenu(self.menuGeometri)
        self.menuScalling.setObjectName("menuScalling")
        self.menuFlip = QtWidgets.QMenu(self.menuGeometri)
        self.menuFlip.setObjectName("menuFlip")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuAritmatical_Operation = QtWidgets.QMenu(self.menubar)
        self.menuAritmatical_Operation.setObjectName("menuAritmatical_Operation")
        self.menuImage_Processing = QtWidgets.QMenu(self.menubar)
        self.menuImage_Processing.setObjectName("menuImage_Processing")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        self.menuKonvolusi = QtWidgets.QMenu(self.menubar)
        self.menuKonvolusi.setObjectName("menuKonvolusi")
        self.menuEdge_Detection = QtWidgets.QMenu(self.menuKonvolusi)
        self.menuEdge_Detection.setObjectName("menuEdge_Detection")
        self.menuSegmentasi_Citra = QtWidgets.QMenu(self.menubar)
        self.menuSegmentasi_Citra.setObjectName("menuSegmentasi_Citra")
        self.menuROI = QtWidgets.QMenu(self.menubar)
        self.menuROI.setObjectName("menuROI")
        self.menuMorfologi = QtWidgets.QMenu(self.menubar)
        self.menuMorfologi.setObjectName("menuMorfologi")
        self.menuDilasi = QtWidgets.QMenu(self.menuMorfologi)
        self.menuDilasi.setObjectName("menuDilasi")
        self.menuErosi = QtWidgets.QMenu(self.menuMorfologi)
        self.menuErosi.setObjectName("menuErosi")
        self.menuOpening = QtWidgets.QMenu(self.menuMorfologi)
        self.menuOpening.setObjectName("menuOpening")
        self.menuClosing = QtWidgets.QMenu(self.menuMorfologi)
        self.menuClosing.setObjectName("menuClosing")
        self.menuEkstraksi_Fitur = QtWidgets.QMenu(self.menubar)
        self.menuEkstraksi_Fitur.setObjectName("menuEkstraksi_Fitur")
        MainWindow.setMenuBar(self.menubar)
        self.actionBrightness_Contrast = QtWidgets.QAction(MainWindow)
        self.actionBrightness_Contrast.setObjectName("actionBrightness_Contrast")
        self.actionInvers = QtWidgets.QAction(MainWindow)
        self.actionInvers.setObjectName("actionInvers")
        self.actionAverage = QtWidgets.QAction(MainWindow)
        self.actionAverage.setObjectName("actionAverage")
        self.actionLightness = QtWidgets.QAction(MainWindow)
        self.actionLightness.setObjectName("actionLightness")
        self.actionLuminance = QtWidgets.QAction(MainWindow)
        self.actionLuminance.setObjectName("actionLuminance")
        self.actionOpen_File = QtWidgets.QAction(MainWindow)
        self.actionOpen_File.setObjectName("actionOpen_File")
        self.actionSave_As = QtWidgets.QAction(MainWindow)
        self.actionSave_As.setObjectName("actionSave_As")
        self.actionKeluar = QtWidgets.QAction(MainWindow)
        self.actionKeluar.setObjectName("actionKeluar")
        self.actionRotasi = QtWidgets.QAction(MainWindow)
        self.actionRotasi.setObjectName("actionRotasi")
        self.actionCroping = QtWidgets.QAction(MainWindow)
        self.actionCroping.setObjectName("actionCroping")
        self.action1_bit = QtWidgets.QAction(MainWindow)
        self.action1_bit.setObjectName("action1_bit")
        self.action2_bit = QtWidgets.QAction(MainWindow)
        self.action2_bit.setObjectName("action2_bit")
        self.action3_bit = QtWidgets.QAction(MainWindow)
        self.action3_bit.setObjectName("action3_bit")
        self.action4_bit = QtWidgets.QAction(MainWindow)
        self.action4_bit.setObjectName("action4_bit")
        self.action5_bit = QtWidgets.QAction(MainWindow)
        self.action5_bit.setObjectName("action5_bit")
        self.action6_bit = QtWidgets.QAction(MainWindow)
        self.action6_bit.setObjectName("action6_bit")
        self.action7_bit = QtWidgets.QAction(MainWindow)
        self.action7_bit.setObjectName("action7_bit")
        self.actionHistogram_Equalization = QtWidgets.QAction(MainWindow)
        self.actionHistogram_Equalization.setObjectName("actionHistogram_Equalization")
        self.actionFuzzy_Histogram_Equalization_RGB = QtWidgets.QAction(MainWindow)
        self.actionFuzzy_Histogram_Equalization_RGB.setObjectName("actionFuzzy_Histogram_Equalization_RGB")
        self.actionFuzzy_Histogram_Equalization_Grayscale = QtWidgets.QAction(MainWindow)
        self.actionFuzzy_Histogram_Equalization_Grayscale.setObjectName("actionFuzzy_Histogram_Equalization_Grayscale")
        self.actionTranslasi = QtWidgets.QAction(MainWindow)
        self.actionTranslasi.setObjectName("actionTranslasi")
        self.actionUniform_Scalling = QtWidgets.QAction(MainWindow)
        self.actionUniform_Scalling.setObjectName("actionUniform_Scalling")
        self.actionNon_Uniform_Scalling = QtWidgets.QAction(MainWindow)
        self.actionNon_Uniform_Scalling.setObjectName("actionNon_Uniform_Scalling")
        self.actionAritmatical = QtWidgets.QAction(MainWindow)
        self.actionAritmatical.setObjectName("actionAritmatical")
        self.actionFlip_Horizontal = QtWidgets.QAction(MainWindow)
        self.actionFlip_Horizontal.setObjectName("actionFlip_Horizontal")
        self.actionFlip_Vertical = QtWidgets.QAction(MainWindow)
        self.actionFlip_Vertical.setObjectName("actionFlip_Vertical")
        self.actionHistogram_Input = QtWidgets.QAction(MainWindow)
        self.actionHistogram_Input.setObjectName("actionHistogram_Input")
        self.actionHistogram_Output = QtWidgets.QAction(MainWindow)
        self.actionHistogram_Output.setObjectName("actionHistogram_Output")
        self.actionHistogram_Input_Output = QtWidgets.QAction(MainWindow)
        self.actionHistogram_Input_Output.setObjectName("actionHistogram_Input_Output")
        self.actionLow_Pass_Filter = QtWidgets.QAction(MainWindow)
        self.actionLow_Pass_Filter.setObjectName("actionLow_Pass_Filter")
        self.actionHigh_Pass_Filter = QtWidgets.QAction(MainWindow)
        self.actionHigh_Pass_Filter.setObjectName("actionHigh_Pass_Filter")
        self.actionIdentity = QtWidgets.QAction(MainWindow)
        self.actionIdentity.setObjectName("actionIdentity")
        self.actionSharpen = QtWidgets.QAction(MainWindow)
        self.actionSharpen.setObjectName("actionSharpen")
        self.actionGaussian_Blur_3_x_3 = QtWidgets.QAction(MainWindow)
        self.actionGaussian_Blur_3_x_3.setObjectName("actionGaussian_Blur_3_x_3")
        self.actionGaussian_Blur_5_x_5 = QtWidgets.QAction(MainWindow)
        self.actionGaussian_Blur_5_x_5.setObjectName("actionGaussian_Blur_5_x_5")
        self.actionUnsharp_Masking = QtWidgets.QAction(MainWindow)
        self.actionUnsharp_Masking.setObjectName("actionUnsharp_Masking")
        self.actionRobert = QtWidgets.QAction(MainWindow)
        self.actionRobert.setObjectName("actionRobert")
        self.actionSobel = QtWidgets.QAction(MainWindow)
        self.actionSobel.setObjectName("actionSobel")
        self.actionPrewit = QtWidgets.QAction(MainWindow)
        self.actionPrewit.setObjectName("actionPrewit")
        self.actionSquare_3 = QtWidgets.QAction(MainWindow)
        self.actionSquare_3.setObjectName("actionSquare_3")
        self.actionSquare_5 = QtWidgets.QAction(MainWindow)
        self.actionSquare_5.setObjectName("actionSquare_5")
        self.actionCross_3 = QtWidgets.QAction(MainWindow)
        self.actionCross_3.setObjectName("actionCross_3")
        self.actionSquare_4 = QtWidgets.QAction(MainWindow)
        self.actionSquare_4.setObjectName("actionSquare_4")
        self.actionSquare_6 = QtWidgets.QAction(MainWindow)
        self.actionSquare_6.setObjectName("actionSquare_6")
        self.actionCross_4 = QtWidgets.QAction(MainWindow)
        self.actionCross_4.setObjectName("actionCross_4")
        self.actionSquare_9 = QtWidgets.QAction(MainWindow)
        self.actionSquare_9.setObjectName("actionSquare_9")
        self.actionSquare_10 = QtWidgets.QAction(MainWindow)
        self.actionSquare_10.setObjectName("actionSquare_10")
        self.actionSegmentasi = QtWidgets.QAction(MainWindow)
        self.actionSegmentasi.setObjectName("actionSegmentasi")
        self.actionDeteksi = QtWidgets.QAction(MainWindow)
        self.actionDeteksi.setObjectName("actionDeteksi")
        self.actionRegion_of_Interest = QtWidgets.QAction(MainWindow)
        self.actionRegion_of_Interest.setObjectName("actionRegion_of_Interest")
        self.actionRemove_Background = QtWidgets.QAction(MainWindow)
        self.actionRemove_Background.setObjectName("Remove_Background")
        self.actionThreshold = QtWidgets.QAction(MainWindow)
        self.actionThreshold.setObjectName("actionThreshold")
        self.actionRGB = QtWidgets.QAction(MainWindow)
        self.actionRGB.setObjectName("actionRGB")
        self.actionRGB_to_HSV = QtWidgets.QAction(MainWindow)
        self.actionRGB_to_HSV.setObjectName("actionRGB_to_HSV")
        self.actionRGB_to_YCrCb = QtWidgets.QAction(MainWindow)
        self.actionRGB_to_YCrCb.setObjectName("actionRGB_to_YCrCb")
        self.menuRGB_to_Grayscale.addAction(self.actionAverage)
        self.menuRGB_to_Grayscale.addAction(self.actionLightness)
        self.menuRGB_to_Grayscale.addAction(self.actionLuminance)
        self.menuBit_Depth.addAction(self.action1_bit)
        self.menuBit_Depth.addAction(self.action2_bit)
        self.menuBit_Depth.addAction(self.action3_bit)
        self.menuBit_Depth.addAction(self.action4_bit)
        self.menuBit_Depth.addAction(self.action5_bit)
        self.menuBit_Depth.addAction(self.action6_bit)
        self.menuBit_Depth.addAction(self.action7_bit)
        self.menuColors.addAction(self.menuRGB_to_Grayscale.menuAction())
        self.menuColors.addAction(self.actionBrightness_Contrast)
        self.menuColors.addAction(self.actionInvers)
        self.menuColors.addAction(self.menuBit_Depth.menuAction())
        self.menuColors.addAction(self.actionThreshold)
        self.menuScalling.addAction(self.actionUniform_Scalling)
        self.menuScalling.addAction(self.actionNon_Uniform_Scalling)
        self.menuFlip.addAction(self.actionFlip_Horizontal)
        self.menuFlip.addAction(self.actionFlip_Vertical)
        self.menuGeometri.addAction(self.actionRotasi)
        self.menuGeometri.addAction(self.actionCroping)
        self.menuGeometri.addAction(self.menuScalling.menuAction())
        self.menuGeometri.addAction(self.actionTranslasi)
        self.menuGeometri.addAction(self.menuFlip.menuAction())
        self.menuFile.addAction(self.actionOpen_File)
        self.menuFile.addAction(self.actionSave_As)
        self.menuFile.addAction(self.actionKeluar)
        self.menuAritmatical_Operation.addAction(self.actionAritmatical)
        self.menuImage_Processing.addAction(self.actionHistogram_Equalization)
        self.menuImage_Processing.addAction(self.actionFuzzy_Histogram_Equalization_RGB)
        self.menuImage_Processing.addAction(self.actionFuzzy_Histogram_Equalization_Grayscale)
        self.menuView.addAction(self.actionHistogram_Input)
        self.menuView.addAction(self.actionHistogram_Output)
        self.menuView.addAction(self.actionHistogram_Input_Output)
        self.menuEdge_Detection.addAction(self.actionRobert)
        self.menuEdge_Detection.addAction(self.actionSobel)
        self.menuEdge_Detection.addAction(self.actionPrewit)
        self.menuKonvolusi.addAction(self.actionLow_Pass_Filter)
        self.menuKonvolusi.addAction(self.actionHigh_Pass_Filter)
        self.menuKonvolusi.addAction(self.actionIdentity)
        self.menuKonvolusi.addAction(self.menuEdge_Detection.menuAction())
        self.menuKonvolusi.addAction(self.actionSharpen)
        self.menuKonvolusi.addAction(self.actionGaussian_Blur_3_x_3)
        self.menuKonvolusi.addAction(self.actionGaussian_Blur_5_x_5)
        self.menuKonvolusi.addAction(self.actionUnsharp_Masking)
        self.menuSegmentasi_Citra.addAction(self.actionSegmentasi)
        self.menuSegmentasi_Citra.addAction(self.actionDeteksi)
        self.menuROI.addAction(self.actionRegion_of_Interest)
        self.menuROI.addAction(self.actionRemove_Background)
        self.menuDilasi.addAction(self.actionSquare_3)
        self.menuDilasi.addAction(self.actionSquare_5)
        self.menuDilasi.addAction(self.actionCross_3)
        self.menuErosi.addAction(self.actionSquare_4)
        self.menuErosi.addAction(self.actionSquare_6)
        self.menuErosi.addAction(self.actionCross_4)
        self.menuOpening.addAction(self.actionSquare_9)
        self.menuClosing.addAction(self.actionSquare_10)
        self.menuMorfologi.addAction(self.menuDilasi.menuAction())
        self.menuMorfologi.addAction(self.menuErosi.menuAction())
        self.menuMorfologi.addAction(self.menuOpening.menuAction())
        self.menuMorfologi.addAction(self.menuClosing.menuAction())
        self.menuEkstraksi_Fitur.addAction(self.actionRGB)
        self.menuEkstraksi_Fitur.addAction(self.actionRGB_to_HSV)
        self.menuEkstraksi_Fitur.addAction(self.actionRGB_to_YCrCb)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuColors.menuAction())
        self.menubar.addAction(self.menuGeometri.menuAction())
        self.menubar.addAction(self.menuAritmatical_Operation.menuAction())
        self.menubar.addAction(self.menuImage_Processing.menuAction())
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuKonvolusi.menuAction())
        self.menubar.addAction(self.menuSegmentasi_Citra.menuAction())
        self.menubar.addAction(self.menuROI.menuAction())
        self.menubar.addAction(self.menuMorfologi.menuAction())
        self.menubar.addAction(self.menuEkstraksi_Fitur.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.menuColors.setTitle(_translate("MainWindow", "Colors"))
        self.menuRGB_to_Grayscale.setTitle(_translate("MainWindow", "RGB to Grayscale"))
        self.menuBit_Depth.setTitle(_translate("MainWindow", "Bit Depth"))
        self.menuGeometri.setTitle(_translate("MainWindow", "Geometric"))
        self.menuScalling.setTitle(_translate("MainWindow", "Scalling "))
        self.menuFlip.setTitle(_translate("MainWindow", "Flip"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuAritmatical_Operation.setTitle(_translate("MainWindow", "Aritmatical"))
        self.menuImage_Processing.setTitle(_translate("MainWindow", "Image Processing"))
        self.menuView.setTitle(_translate("MainWindow", "View"))
        self.menuKonvolusi.setTitle(_translate("MainWindow", "Konvolusi"))
        self.menuEdge_Detection.setTitle(_translate("MainWindow", "Edge Detection"))
        self.menuSegmentasi_Citra.setTitle(_translate("MainWindow", "Segmentasi Citra"))
        self.menuROI.setTitle(_translate("MainWindow", "ROI"))
        self.menuMorfologi.setTitle(_translate("MainWindow", "Morfologi"))
        self.menuDilasi.setTitle(_translate("MainWindow", "Dilasi"))
        self.menuErosi.setTitle(_translate("MainWindow", "Erosi"))
        self.menuOpening.setTitle(_translate("MainWindow", "Opening"))
        self.menuClosing.setTitle(_translate("MainWindow", "Closing"))
        self.menuEkstraksi_Fitur.setTitle(_translate("MainWindow", "Ekstraksi Fitur"))
        self.actionBrightness_Contrast.setText(_translate("MainWindow", "Brightness - Contrast"))
        self.actionInvers.setText(_translate("MainWindow", "Invers"))
        self.actionAverage.setText(_translate("MainWindow", "Average"))
        self.actionLightness.setText(_translate("MainWindow", "Lightness"))
        self.actionLuminance.setText(_translate("MainWindow", "Luminance"))
        self.actionOpen_File.setText(_translate("MainWindow", "Open File"))
        self.actionSave_As.setText(_translate("MainWindow", "Save As"))
        self.actionKeluar.setText(_translate("MainWindow", "Keluar"))
        self.actionRotasi.setText(_translate("MainWindow", "Rotasi"))
        self.actionCroping.setText(_translate("MainWindow", "Croping"))
        self.action1_bit.setText(_translate("MainWindow", "1 bit"))
        self.action2_bit.setText(_translate("MainWindow", "2 bit"))
        self.action3_bit.setText(_translate("MainWindow", "3 bit"))
        self.action4_bit.setText(_translate("MainWindow", "4 bit"))
        self.action5_bit.setText(_translate("MainWindow", "5 bit"))
        self.action6_bit.setText(_translate("MainWindow", "6 bit"))
        self.action7_bit.setText(_translate("MainWindow", "7 bit"))
        self.actionHistogram_Equalization.setText(_translate("MainWindow", "Histogram Equalization"))
        self.actionFuzzy_Histogram_Equalization_RGB.setText(_translate("MainWindow", "Fuzzy Histogram Equalization RGB"))
        self.actionFuzzy_Histogram_Equalization_Grayscale.setText(_translate("MainWindow", "Fuzzy Histogram Equalization Grayscale"))
        self.actionTranslasi.setText(_translate("MainWindow", "Translasi"))
        self.actionUniform_Scalling.setText(_translate("MainWindow", "Uniform Scalling"))
        self.actionNon_Uniform_Scalling.setText(_translate("MainWindow", "Non-Uniform Scalling"))
        self.actionAritmatical.setText(_translate("MainWindow", "Aritmatical"))
        self.actionFlip_Horizontal.setText(_translate("MainWindow", "Flip Horizontal"))
        self.actionFlip_Vertical.setText(_translate("MainWindow", "Flip Vertical"))
        self.actionHistogram_Input.setText(_translate("MainWindow", "Histogram Input"))
        self.actionHistogram_Output.setText(_translate("MainWindow", "Histogram Output"))
        self.actionHistogram_Input_Output.setText(_translate("MainWindow", "Histogram Input-Output"))
        self.actionLow_Pass_Filter.setText(_translate("MainWindow", "Low Pass Filter"))
        self.actionHigh_Pass_Filter.setText(_translate("MainWindow", "High Pass Filter"))
        self.actionIdentity.setText(_translate("MainWindow", "Identity"))
        self.actionSharpen.setText(_translate("MainWindow", "Sharpen"))
        self.actionGaussian_Blur_3_x_3.setText(_translate("MainWindow", "Gaussian Blur 3 x 3"))
        self.actionGaussian_Blur_5_x_5.setText(_translate("MainWindow", "Gaussian Blur 5 x 5"))
        self.actionUnsharp_Masking.setText(_translate("MainWindow", "Unsharp Masking"))
        self.actionRobert.setText(_translate("MainWindow", "Robert"))
        self.actionSobel.setText(_translate("MainWindow", "Sobel"))
        self.actionPrewit.setText(_translate("MainWindow", "Prewit"))
        self.actionSquare_3.setText(_translate("MainWindow", "Square 3"))
        self.actionSquare_5.setText(_translate("MainWindow", "Square 5"))
        self.actionCross_3.setText(_translate("MainWindow", "Cross 3"))
        self.actionSquare_4.setText(_translate("MainWindow", "Square 3"))
        self.actionSquare_6.setText(_translate("MainWindow", "Square 5"))
        self.actionCross_4.setText(_translate("MainWindow", "Cross 3"))
        self.actionSquare_9.setText(_translate("MainWindow", "Square 9"))
        self.actionSquare_10.setText(_translate("MainWindow", "Square 9"))
        self.actionSegmentasi.setText(_translate("MainWindow", "Segmentasi"))
        self.actionDeteksi.setText(_translate("MainWindow", "Deteksi"))
        self.actionRegion_of_Interest.setText(_translate("MainWindow", "Region of Interest"))
        self.actionRemove_Background.setText(_translate("MainWindow", "Remove Background"))
        self.actionThreshold.setText(_translate("MainWindow", "Threshold"))
        self.actionRGB.setText(_translate("MainWindow", "RGB"))
        self.actionRGB_to_HSV.setText(_translate("MainWindow", "RGB to HSV"))
        self.actionRGB_to_YCrCb.setText(_translate("MainWindow", "RGB to YCrCb"))


        self.actionSave_As.triggered.connect(self.save_image)
        self.actionKeluar.triggered.connect(QtWidgets.qApp.quit)
        self.actionAverage.triggered.connect(self.rgb_to_grayscale_average)
        self.actionLightness.triggered.connect(self.rgb_to_grayscale_lightness)
        self.actionLuminance.triggered.connect(self.rgb_to_grayscale_luminance)
        self.actionInvers.triggered.connect(self.invert_colors)
        self.actionOpen_File.triggered.connect(self.open_image_and_display_path)
        self.actionBrightness_Contrast.triggered.connect(self.open_brightness_contrast_dialog)
        self.actionRotasi.triggered.connect(self.rotate_image)
        self.actionFlip_Horizontal.triggered.connect(self.flip_horizontal)
        self.actionFlip_Vertical.triggered.connect(self.flip_vertical)
        self.actionAritmatical.triggered.connect(self.open_aritmatika)
        self.action1_bit.triggered.connect(self.reduce_to_1_bit)
        self.action2_bit.triggered.connect(self.reduce_to_2_bit)
        self.action3_bit.triggered.connect(self.reduce_to_3_bit)
        self.action4_bit.triggered.connect(self.reduce_to_4_bit)
        self.action5_bit.triggered.connect(self.reduce_to_5_bit)
        self.action6_bit.triggered.connect(self.reduce_to_6_bit)
        self.action7_bit.triggered.connect(self.reduce_to_7_bit)
        self.actionCroping.triggered.connect(self.crop_image)
        self.actionUniform_Scalling.triggered.connect(self.uniform_scaling)
        self.actionNon_Uniform_Scalling.triggered.connect(self.non_uniform_scaling)
        self.actionHistogram_Equalization.triggered.connect(self.histogram_equalization)
        self.actionFuzzy_Histogram_Equalization_RGB.triggered.connect(self.fuzzy_histogram_equalization_rgb)
        self.actionFuzzy_Histogram_Equalization_Grayscale.triggered.connect(self.fuzzy_histogram_equalization_grayscale)
        self.actionHistogram_Input.triggered.connect(self.display_input_histogram)
        self.actionHistogram_Output.triggered.connect(self.display_output_histogram)
        self.actionHistogram_Input_Output.triggered.connect(self.display_input_output_histogram)
        self.actionTranslasi.triggered.connect(self.translasi_image)
        self.actionHigh_Pass_Filter.triggered.connect(self.apply_high_pass_filter)
        self.actionLow_Pass_Filter.triggered.connect(self.apply_low_pass_filter)
        self.actionIdentity.triggered.connect(self.apply_identity_filter)
        self.actionRobert.triggered.connect(self.apply_edge_detection_robert)
        self.actionSobel.triggered.connect(self.apply_edge_detection_sobel)
        self.actionPrewit.triggered.connect(self.apply_edge_detection_prewit)
        self.actionSharpen.triggered.connect(self.apply_sharpen_filter)
        self.actionGaussian_Blur_3_x_3.triggered.connect(self.apply_gaussian_blur_3x3)
        self.actionGaussian_Blur_5_x_5.triggered.connect(self.apply_gaussian_blur_5x5)
        self.actionUnsharp_Masking.triggered.connect(self.apply_unsharp_masking)
        self.actionSquare_3.triggered.connect(self.dilasi_square_3)
        self.actionSquare_5.triggered.connect(self.dilasi_square_5)
        self.actionCross_3.triggered.connect(self.dilasi_cross_3)
        self.actionSquare_4.triggered.connect(self.erosi_square_3)
        self.actionSquare_6.triggered.connect(self.erosi_square_5)
        self.actionCross_4.triggered.connect(self.erosi_cross_3)
        self.actionSquare_9.triggered.connect(self.opening_square_9)
        self.actionSquare_10.triggered.connect(self.closing_square_9)
        self.actionSegmentasi.triggered.connect(self.segmentImage)
        self.actionDeteksi.triggered.connect(self.RemoveBg)
        self.actionRegion_of_Interest.triggered.connect(self.region_of_interest)
        self.actionRemove_Background.triggered.connect(self.removeBackground)
        self.actionThreshold.triggered.connect(self.apply_threshold)
        self.actionRGB_to_HSV.triggered.connect(self.apply_rgb_to_hsv)
        self.actionRGB_to_HSV.triggered.connect(self.rgbToHsv)
        self.actionRGB_to_YCrCb.triggered.connect(self.apply_rgb_to_ycrcb)
        self.actionRGB_to_YCrCb.triggered.connect(self.rgbToYCrCb)
        self.actionRGB.triggered.connect(self.apply_rgb)
        self.actionRGB.triggered.connect(self.ekstrakRgb)

    def process_images_in_folder(self):
        folder_path = QFileDialog.getExistingDirectory(None, "Select a folder with images")
        if folder_path:
            image_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff'))]
            
            if not image_files:
                messagebox.warning(None, "No Images Found", "No image files found in the selected folder.")
                return

            total_Y, total_Cb, total_Cr = 0, 0, 0
            num_images = 0

            for image_file in image_files:
                image_path = os.path.join(folder_path, image_file)
                input_image = QPixmap(image_path)
                width = input_image.width()
                height = input_image.height()

                # Mengambil data piksel dari QImage
                ptr = input_image.toImage().constBits()
                ptr.setsize(height * width * 4)  # 4 bytes per piksel untuk RGBA

                # Mengonversi data piksel ke array numpy dan ubah ukuran ke (height, width, 4)
                image = np.array(ptr).reshape(height, width, 4)

                # Ambil komponen RGB (R,G,B) dan normalisasikan
                r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]
                r, g, b = r / 255.0, g / 255.0, b / 255.0

                Y = 0 + 0.299*r + 0.587*g + 0.114 *b
                Cb = 128 + (-0.169 * r -0.331 * g + 0.500 *b)
                Cr = 128 + 0.500 * r -0.419* g - 0.081 * b

                total_Y += np.sum(Y)
                total_Cb += np.sum(Cb)
                total_Cr += np.sum(Cr)
                num_images += (height * width)

            # Hitung rata-rata dari semua gambar
            avg_Y = total_Y / num_images
            avg_Cb = total_Cb / num_images
            avg_Cr = total_Cr / num_images

            # Tampilkan hasil dalam dataframe
            data = pd.DataFrame({'Average Y': [avg_Y], 'Average Cb': [avg_Cb], 'Average Cr': [avg_Cr]})

            export_path, _ = QFileDialog.getSaveFileName(None, "Save YCrCb Data", "", "Excel Files (*.xlsx)")
            if export_path:
                data.to_excel(export_path, index=False)

    def RemoveBg(self):
        if self.label.pixmap() is not None:
            input_pixmap = self.label.pixmap()
            if input_pixmap is not None:
                input_pixmap.save("Gambar/temp_input.png") # Save temporary input image

                with open("Gambar/temp_input.png", "rb") as input_file:
                    output_data = remove(input_file.read())
                    with open("Gambar/temp_output.png", "wb") as output_file:
                        output_file.write(output_data)

                # Load the image
                image = cv2.imread('Gambar/temp_output.png')

                # Convert the image to gray scale
                gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

                # Use thresholding to get the contours of the objects
                _, thresh = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)
                contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                # Load the original image
                original = cv2.imread('Gambar/temp_input.png')

                # Draw bounding box for each object on the original image
                for cnt in contours:
                    x, y, w, h = cv2.boundingRect(cnt)
                    # Extract the region of interest (ROI) for the object
                    roi = original[y:y+h, x:x+w]
                    # Calculate the mean color of the object
                    mean_color = np.mean(roi, axis=(0, 1)).astype(int)
                    # Draw bounding box with the mean color
                    cv2.rectangle(original, (x, y), (x + w, y + h), (int(mean_color[0]), int(mean_color[1]), int(mean_color[2])), 2)

                # Save the original image with bounding boxes
                cv2.imwrite('Gambar/final_output.png', original)

                output_pixmap = QPixmap("Gambar/final_output.png")
                self.label_2.setPixmap(output_pixmap)

            if os.path.exists("Gambar/temp_input.png"):
                os.remove("Gambar/temp_input.png")
            if os.path.exists("Gambar/temp_output.png"):
                os.remove("Gambar/temp_output.png")
            if os.path.exists("Gambar/final_output.png"):
                os.remove("Gambar/final_output.png")

    def segmentImage(self):
        if self.label:
            # Convert QPixmap to QImage for image processing
            input_qimage = self.label.pixmap().toImage()
            width = input_qimage.width()
            height = input_qimage.height()

            total_pixels = width * height
            processed_pixels = 0

            # Create a new QImage for the processed image
            output_qimage = QtGui.QImage(width, height, QtGui.QImage.Format_RGB32)

            for x in range(1, width - 1):
                for y in range(1, height - 1):
                    gx = 0
                    gy = 0
                    
                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

                    for dx in [-1, 0, 1]:
                        for dy in [-1, 0, 1]:
                            pixel_color = QtGui.QColor(input_qimage.pixel(x + dx, y + dy))
                            intensity = pixel_color.red()  # Using red channel for grayscale

                            # Sobel masks
                            if dx == -1:
                                gx -= intensity
                            elif dx == 1:
                                gx += intensity
                            if dy == -1:
                                gy -= intensity
                            elif dy == 1:
                                gy += intensity

                    edge_intensity = min(int(abs(gx) + abs(gy)), 255)
                    output_qimage.setPixelColor(x, y, QtGui.QColor(edge_intensity, edge_intensity, edge_intensity))

            # Convert QImage to QPixmap for display
            self.output_image = QtGui.QPixmap.fromImage(output_qimage)
            self.label_2.setPixmap(self.output_image)
            self.label_2.setScaledContents(True)
            self.progressBar.setValue(0)

    def removeBackground(self):
        if self.label.pixmap() is not None:
            input_pixmap = self.label.pixmap()
            if input_pixmap is not None:
                input_pixmap.save("Gambar/temp_input.png") # Save temporary input image

                with open("Gambar/temp_input.png", "rb") as input_file:
                    output_data = remove(input_file.read())
                    with open("Gambar/temp_output.png", "wb") as output_file:
                        output_file.write(output_data)

                output_pixmap = QPixmap("Gambar/temp_output.png")
                self.label_2.setPixmap(output_pixmap)

                # Hapus berkas temp_input.png dan temp_output.png setelah ditampilkan
                if os.path.exists("Gambar/temp_input.png"):
                    os.remove("Gambar/temp_input.png")
                if os.path.exists("Gambar/temp_output.png"):
                    os.remove("Gambar/temp_output.png")

    def ekstrakRgb(self):
        if self.label.pixmap() is not None:
            input_image = self.label.pixmap().toImage()
            width = input_image.width()
            height = input_image.height()

            # Mengambil data piksel dari QImage
            ptr = input_image.constBits()
            ptr.setsize(height * width * 4)  # 4 bytes per piksel untuk RGBA
            
            # Mengonversi data piksel ke array numpy dan ubah ukuran ke (height, width, 4)
            image = np.array(ptr).reshape(height, width, 4)
            
            # Ambil komponen RGB (R,G,B) dan normalisasikan
            r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]
            r, g, b = r / 255.0, g / 255.0, b / 255.0

            avg_r = np.mean(r)
            avg_g = np.mean(g)
            avg_b = np.mean(b)

            # Tampilkan dalam dataframe
            data = pd.DataFrame([[avg_r, avg_g, avg_b]], columns=['Average R', 'Average G', 'Average B'])

            export_path, _ = QFileDialog.getSaveFileName(None, "Save RGB Data", "", "Excel Files (*.xlsx)")
            if export_path:
                data.to_excel(export_path, index=False)

    def rgbToHsv(self):
        if self.label.pixmap() is not None:
            input_image = self.label.pixmap().toImage()
            
            # Mengubah QImage ke format RGB888
            input_image = input_image.convertToFormat(QImage.Format_RGB888)
            
            width = input_image.width()
            height = input_image.height()
            
            # Mengambil data piksel dari QImage
            ptr = input_image.constBits()
            ptr.setsize(height * width * 3)  # 3 bytes per piksel untuk RGB
            
            # Mengonversi data piksel ke array numpy
            image = np.array(ptr).reshape(height, width, 3)
            
            # Normalisasi nilai piksel
            image = image.astype(float) / 255.0

            r, g, b = cv2.split(image)

            max_v = np.max([r, g, b], axis=0)
            min_v = np.min([r, g, b], axis=0)

            v = max_v

            s = np.where(max_v == 0, 0, (max_v - min_v) / max_v)

            h = np.zeros_like(max_v)
            h[max_v == r] = np.where(max_v[max_v == r] == min_v[max_v == r], 0, 60 * (0 + (g - b) / (max_v - min_v))[max_v == r])
            h[max_v == g] = np.where(max_v[max_v == g] == min_v[max_v == g], 0, 60 * (2 + (b - r) / (max_v - min_v))[max_v == g])
            h[max_v == b] = np.where(max_v[max_v == b] == min_v[max_v == b], 0, 60 * (4 + (r - g) / (max_v - min_v))[max_v == b])

            h[h < 0] += 360

            # Hitung rata-rata H, S, V
            avg_h = np.mean(h)
            avg_s = np.mean(s)
            avg_v = np.mean(v)

            # Tampilkan dalam dataframe
            data = pd.DataFrame([[avg_h, avg_s, avg_v]], columns=['Average H', 'Average S', 'Average V'])

            export_path, _ = QFileDialog.getSaveFileName(None, "Save HSV Data", "", "Excel Files (*.xlsx)")
            if export_path:
                data.to_excel(export_path, index=False)
    
    def rgbToYCrCb(self):
        if self.label.pixmap() is not None:
            input_image = self.label.pixmap().toImage()
            width = input_image.width()
            height = input_image.height()

            # Mengambil data piksel dari QImage
            ptr = input_image.constBits()
            ptr.setsize(height * width * 4)  # 4 bytes per piksel untuk RGBA
            
            # Mengonversi data piksel ke array numpy dan ubah ukuran ke (height, width, 4)
            image = np.array(ptr).reshape(height, width, 4)
            
            # Ambil komponen RGB (R,G,B) dan normalisasikan
            r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]
            r, g, b = r / 255.0, g / 255.0, b / 255.0

            Y = 0 + 0.299*r + 0.587*g + 0.114 *b
            Cb = 128 + (-0.169 * r -0.331 * g + 0.500 *b)
            Cr = 128 + 0.500 * r -0.419* g - 0.081 * b

            avg_Y = np.mean(Y)
            avg_Cb = np.mean(Cb)
            avg_Cr = np.mean(Cr)

            # Tampilkan dalam dataframe
            data = pd.DataFrame([[avg_Y, avg_Cb, avg_Cr]], columns=['Average Y', 'Average Cb', 'Average Cr'])

            export_path, _ = QFileDialog.getSaveFileName(None, "Save YCrCb Data", "", "Excel Files (*.xlsx)")
            if export_path:
                data.to_excel(export_path, index=False)

    def apply_rgb(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            pixmap_2 = QPixmap.fromImage(image)
            self.label_2.setPixmap(pixmap_2)

    def apply_rgb_to_ycrcb(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            processed_image = QImage(width, height, QImage.Format_RGB888)

            for y in range(height):
                for x in range(width):
                    color = QColor(image.pixel(x, y))
                    r, g, b = color.red(), color.green(), color.blue()

                    # Konversi RGB ke YCrCb
                    y_value = int(0.299 * r + 0.587 * g + 0.114 * b)
                    cr_value = int(128 + 0.5 * r - 0.418688 * g - 0.081312 * b)
                    cb_value = int(128 - 0.168736 * r - 0.331264 * g + 0.5 * b)

                    # Pastikan nilai-nilai berada dalam rentang 0-255
                    y_value = max(0, min(255, y_value))
                    cr_value = max(0, min(255, cr_value))
                    cb_value = max(0, min(255, cb_value))

                    processed_image.setPixel(x, y, QColor(y_value, cr_value, cb_value).rgb())

            pixmap = QPixmap.fromImage(processed_image)
            self.label_2.setPixmap(pixmap)

    def apply_rgb_to_hsv(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            processed_image = QImage(width, height, QImage.Format_RGB888)

            for y in range(height):
                for x in range(width):
                    color = QColor(image.pixel(x, y))
                    r, g, b = color.red(), color.green(), color.blue()
                    r, g, b = r / 255.0, g / 255.0, b / 255.0

                    max_val = max(r, g, b)
                    min_val = min(r, g, b)
                    delta = max_val - min_val

                    h = 0.0
                    s = 0.0
                    v = max_val

                    if delta != 0:
                        if max_val == r:
                            h = 60.0 * (((g - b) / delta) % 6)
                        elif max_val == g:
                            h = 60.0 * (((b - r) / delta) + 2)
                        elif max_val == b:
                            h = 60.0 * (((r - g) / delta) + 4)

                        s = delta / max_val

                    h = (h / 360) * 255
                    s = s * 255
                    v = v * 255

                    processed_image.setPixel(x, y, QColor(int(h), int(s), int(v)).rgb())

            pixmap = QPixmap.fromImage(processed_image)
            self.label_2.setPixmap(pixmap)

    def apply_threshold(self):
        threshold, ok = QtWidgets.QInputDialog.getInt(None, "Thresholding", "Enter threshold value:", 128, 0, 255)
        if ok:
            if hasattr(self, 'image'):
                # Convert the image to grayscale if it's not already
                if self.image.format() != QtGui.QImage.Format_Grayscale8:
                    self.image = self.image.convertToFormat(QtGui.QImage.Format_Grayscale8)

                # Apply thresholding
                thresholded_image = self.image.copy()
                for x in range(self.image.width()):
                    for y in range(self.image.height()):
                        pixel_value = self.image.pixelColor(x, y).black()
                        if pixel_value < threshold:
                            thresholded_image.setPixelColor(x, y, QtGui.QColor(0, 0, 0))  # Set pixel to black
                        else:
                            thresholded_image.setPixelColor(x, y, QtGui.QColor(255, 255, 255))  # Set pixel to white

                pixmap = QtGui.QPixmap.fromImage(thresholded_image)
                self.label_2.setPixmap(pixmap)
                self.label_2.setScaledContents(True)

    def open_image_and_display_path(self):
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        self.label_2.clear()
        file_name, _ = QFileDialog.getOpenFileName(None, "Open Image File", "", "Images (*.png *.jpg *.bmp *.jpeg);;All Files (*)", options=options)
        if file_name:
            self.label_3.setText(f"Opened file: {file_name}")

            image = QtGui.QImage(file_name)
            if not image.isNull():
                pixmap = QtGui.QPixmap.fromImage(image)
                self.label.setPixmap(pixmap)
                self.label.setScaledContents(True)
                self.label_2.setScaledContents(True)
                self.image = image

    def dilasi_square_3(self):
        self.apply_morphological_operation(np.array([[1, 1, 1],
                                                     [1, 1, 1],
                                                     [1, 1, 1]]))

    def dilasi_square_5(self):
        self.apply_morphological_operation(np.array([[1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1]]))

    def dilasi_cross_3(self):
        self.apply_morphological_operation(np.array([[0, 1, 0],
                                                     [1, 1, 1],
                                                     [0, 1, 0]]))

    def erosi_square_3(self):
        self.apply_morphological_operation(np.array([[1, 1, 1],
                                                     [1, 1, 1],
                                                     [1, 1, 1]]), erosi=True)

    def erosi_square_5(self):
        self.apply_morphological_operation(np.array([[1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1],
                                                     [1, 1, 1, 1, 1]]), erosi=True)

    def erosi_cross_3(self):
        self.apply_morphological_operation(np.array([[0, 1, 0],
                                                     [1, 1, 1],
                                                     [0, 1, 0]]), erosi=True)
        
    def apply_morphological_operation(self, kernel, erosi=False):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0

            kernel_radius = len(kernel) // 2

            for y in range(kernel_radius, height - kernel_radius):
                for x in range(kernel_radius, width - kernel_radius):
                    if erosi:
                        value = 255  # Set the pixel to white initially for erosion
                        for ky in range(-kernel_radius, kernel_radius + 1):
                            for kx in range(-kernel_radius, kernel_radius + 1):
                                if kernel[ky + kernel_radius][kx + kernel_radius]:
                                    r, g, b, _ = QtGui.QColor(image.pixel(x + kx, y + ky)).getRgb()
                                    pixel_value = (max(r, g, b) + min(r, g, b)) // 2
                                    value = min(value, pixel_value)
                    else:
                        value = 0  # Set the pixel to black initially for dilation
                        for ky in range(-kernel_radius, kernel_radius + 1):
                            for kx in range(-kernel_radius, kernel_radius + 1):
                                if kernel[ky + kernel_radius][kx + kernel_radius]:
                                    r, g, b, _ = QtGui.QColor(image.pixel(x + kx, y + ky)).getRgb()
                                    pixel_value = (max(r, g, b) + min(r, g, b)) // 2
                                    value = max(value, pixel_value)

                    grayscale_image[y][x] = value

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            grayscale_qimage = QtGui.QImage(grayscale_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)

            grayscale_pixmap = QtGui.QPixmap.fromImage(grayscale_qimage)
            self.label_2.setPixmap(grayscale_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def opening_square_9(self):
        if hasattr(self, 'image'):
            kernel_radius = 1
            kernel = np.array([[0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0]])

            kernel_size = kernel.shape[0]
            kernel_center = kernel_size // 2

            pixmap = self.label.pixmap()
            if pixmap:
                image = pixmap.toImage()
                width = image.width()
                height = image.height()

                total_pixels = width * height
                processed_pixels = 0

                processed_image = np.zeros((height, width), dtype=np.uint8)

                for y in range(kernel_center, height - kernel_center):
                    for x in range(kernel_center, width - kernel_center):
                        min_value = 255

                        processed_pixels += 1
                        progress_percent = int((processed_pixels / total_pixels) * 100)
                        self.progressBar.setValue(progress_percent)

                        for ky in range(kernel_size):
                            for kx in range(kernel_size):
                                if kernel[ky][kx]:
                                    pixel_value = QtGui.QColor(image.pixel(x + kx - kernel_center, y + ky - kernel_center)).lightness()
                                    if pixel_value < min_value:
                                        min_value = pixel_value

                        processed_image[y][x] = min_value

                processed_qimage = QtGui.QImage(processed_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
                
                processed_pixmap = QtGui.QPixmap.fromImage(processed_qimage)
                self.label_2.setPixmap(processed_pixmap)
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)
                self.progressBar.setValue(0)

    def closing_square_9(self):
        if hasattr(self, 'image'):
            kernel_radius = 1
            kernel = np.array([[0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0]])

            kernel_size = kernel.shape[0]
            kernel_center = kernel_size // 2

            pixmap = self.label.pixmap()
            if pixmap:
                image = pixmap.toImage()
                width = image.width()
                height = image.height()

                total_pixels = width * height
                processed_pixels = 0

                processed_image = np.zeros((height, width), dtype=np.uint8)

                for y in range(kernel_center, height - kernel_center):
                    for x in range(kernel_center, width - kernel_center):
                        max_value = 0

                        processed_pixels += 1
                        progress_percent = int((processed_pixels / total_pixels) * 100)
                        self.progressBar.setValue(progress_percent)
                        
                        for ky in range(kernel_size):
                            for kx in range(kernel_size):
                                if kernel[ky][kx]:
                                    pixel_value = QtGui.QColor(image.pixel(x + kx - kernel_center, y + ky - kernel_center)).lightness()
                                    if pixel_value > max_value:
                                        max_value = pixel_value

                        processed_image[y][x] = max_value

                processed_qimage = QtGui.QImage(processed_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
                
                processed_pixmap = QtGui.QPixmap.fromImage(processed_qimage)
                self.label_2.setPixmap(processed_pixmap)
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)
                self.progressBar.setValue(0)

    def apply_filter(self, filter_kernel):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            new_image = QtGui.QImage(image)
            new_image.fill(Qt.white)

            total_pixels = width * height
            processed_pixels = 0

            kernel = np.array(filter_kernel)  # Konversi kernel ke NumPy array
            kernel_width, kernel_height = kernel.shape

            for y in range(height):
                for x in range(width):
                    pixel_sum = [0, 0, 0]

                    for ky in range(kernel_height):
                        for kx in range(kernel_width):
                            tx = x + kx - kernel_width // 2
                            ty = y + ky - kernel_height // 2

                            if 0 <= tx < width and 0 <= ty < height:
                                color = QColor(image.pixel(tx, ty))
                                pixel_sum[0] += color.red() * kernel[ky][kx]
                                pixel_sum[1] += color.green() * kernel[ky][kx]
                                pixel_sum[2] += color.blue() * kernel[ky][kx]

                            processed_pixels += 1
                            progress_percent = int((processed_pixels / total_pixels) * 100)
                            self.progressBar.setValue(progress_percent)

                    r = min(max(int(pixel_sum[0]), 0), 255)
                    g = min(max(int(pixel_sum[1]), 0), 255)
                    b = min(max(int(pixel_sum[2]), 0), 255)

                    new_image.setPixelColor(x, y, QColor(r, g, b))

            self.label_2.setPixmap(QPixmap.fromImage(new_image))
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def apply_low_pass_filter(self):
        # Definisi kernel filter tahan rendah (contoh: rata-rata)
        low_pass_kernel = np.array([[1, 1, 1],
                                    [1, 1, 1],
                                    [1, 1, 1]]) / 9.0

        # Terapkan filter tahan rendah
        self.apply_filter(low_pass_kernel)

    def apply_high_pass_filter(self):
        # Definisi kernel filter tahan tinggi (contoh: sharpening)
        high_pass_kernel = np.array([[-1, -1, -1],
                                     [-1,  9, -1],
                                     [-1, -1, -1]])
        
        # Terapkan filter tahan tinggi
        self.apply_filter(high_pass_kernel)

    def apply_identity_filter(self):
        # Definisi kernel filter Identity
        identity_kernel = np.array([[0, 0, 0],
                                     [0, 1, 0],
                                     [0, 0, 0]])

        # Terapkan filter Identity
        self.apply_filter(identity_kernel)

    def apply_edge_detection_robert(self):
        # Definisi kernel filter Edge Detection Robert
        robert_kernel = np.array([[1, 0, -1],
                                  [0, 0, 0],
                                  [-1, 0, 1]])

        # Terapkan filter Edge Detection Robert
        self.apply_filter(robert_kernel)

    def apply_edge_detection_sobel(self):
        # Definisi kernel filter Edge Detection Sobel
        sobel_kernel = np.array([[0, 1, 0],
                                 [1, -4, 1],
                                 [0, 1, 0]])

        # Terapkan filter Edge Detection Sobel
        self.apply_filter(sobel_kernel)

    def apply_edge_detection_prewit(self):
        # Definisi kernel filter Edge Detection Prewit
        prewit_kernel = np.array([[-1, -1, -1],
                                  [-1, 8, -1],
                                  [-1, -1, -1]])

        # Terapkan filter Edge Detection Prewit
        self.apply_filter(prewit_kernel)

    def apply_sharpen_filter(self):
        # Definisi kernel filter Sharpen
        sharpen_kernel = np.array([[0, -1, 0],
                                   [-1, 5, -1],
                                   [0, -1, 0]])

        # Terapkan filter Sharpen
        self.apply_filter(sharpen_kernel)

    def apply_gaussian_blur_3x3(self):
        # Definisi kernel filter Gaussian Blur 3 x 3
        gaussian_blur_kernel = np.array([[1, 2, 1],
                                         [2, 4, 2],
                                         [1, 2, 1]]) / 16.0

        # Terapkan filter Gaussian Blur 3 x 3
        self.apply_filter(gaussian_blur_kernel)

    def apply_gaussian_blur_5x5(self):
        # Definisi kernel filter Gaussian Blur 5 x 5
        gaussian_blur_kernel = np.array([[1, 4, 6, 4, 1],
                                         [4, 16, 24, 16, 4],
                                         [6, 24, 36, 24, 6],
                                         [4, 16, 24, 16, 4],
                                         [1, 4, 6, 4, 1]]) / 256.0

        # Terapkan filter Gaussian Blur 5 x 5
        self.apply_filter(gaussian_blur_kernel)

    def apply_unsharp_masking(self):
        # Definisi kernel filter Unsharp Masking
        unsharp_masking_kernel = np.array([[1, 4, 6, 4, 1],
                                           [4, 16, 24, 16, 4],
                                           [6, 24, -476, 24, 6],
                                           [4, 16, 24, 16, 4],
                                           [1, 4, 6, 4, 1]]) * (-1/256)
        
        # Terapkan filter Unsharp Masking
        self.apply_filter(unsharp_masking_kernel)

    def translasi_image(self):
        if hasattr(self, 'image'):
            if not self.label.pixmap():
                return

            # Menampilkan dialog untuk memasukkan nilai translasi (geser)
            tx, ok1 = QtWidgets.QInputDialog.getInt(None, "Translasi Image", "Enter translation in X direction (pixels):", 0, -self.image.width(), self.image.width())
            ty, ok2 = QtWidgets.QInputDialog.getInt(None, "Translasi Image", "Enter translation in Y direction (pixels):", 0, -self.image.height(), self.image.height())

            if ok1 and ok2:
                # Mendapatkan pixmap yang akan di-translasi
                pixmap = self.label.pixmap()

                # Mendapatkan ukuran asli pixmap
                original_size = pixmap.size()
                width = original_size.width()
                height = original_size.height()

                total_pixels = width * height
                processed_pixels = 0

                # Membuat gambar baru dengan ukuran yang sama seperti pixmap
                new_image = QtGui.QImage(original_size, QtGui.QImage.Format_RGB32)
                new_image.fill(Qt.white)

                for y in range(height):
                    for x in range(width):
                        # Mendapatkan warna piksel asli
                        color = QColor(pixmap.toImage().pixel(x, y))

                        # Menghitung koordinat baru setelah translasi
                        new_x = x + tx
                        new_y = y + ty

                        processed_pixels += 1
                        progress_percent = int((processed_pixels / total_pixels) * 100)
                        self.progressBar.setValue(progress_percent)

                        # Pastikan koordinat baru berada dalam batas gambar
                        if 0 <= new_x < width and 0 <= new_y < height:
                            new_image.setPixel(new_x, new_y, color.rgb())

                # Menampilkan hasil translasi di label_2
                self.label_2.setPixmap(QPixmap.fromImage(new_image))
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)
                self.progressBar.setValue(0)

    def display_input_output_histogram(self):
        input_pixmap = self.label.pixmap()
        output_pixmap = self.label_2.pixmap()

        if input_pixmap and output_pixmap:
            input_image = input_pixmap.toImage()
            output_image = output_pixmap.toImage()

            input_width = input_image.width()
            input_height = input_image.height()

            output_width = output_image.width()
            output_height = output_image.height()

            # Inisialisasi array histogram untuk input dan output
            input_histogram = [0] * 256
            output_histogram = [0] * 256

            total_pixels = output_width * output_height
            processed_pixels = 0

            # Menghitung histogram input
            for y in range(input_height):
                for x in range(input_width):
                    r, g, b, _ = QtGui.QColor(input_image.pixel(x, y)).getRgb()
                    gray_value = int((r + g + b) / 3)
                    input_histogram[gray_value] += 1

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            # Menghitung histogram output
            for y in range(output_height):
                for x in range(output_width):
                    r, g, b, _ = QtGui.QColor(output_image.pixel(x, y)).getRgb()
                    gray_value = int((r + g + b) / 3)
                    output_histogram[gray_value] += 1

            # Menampilkan histogram dalam satu grafik
            plt.figure()
            plt.bar(range(256), input_histogram, width=0.4, alpha=0.5, color='b', label='Input')
            plt.bar(range(256), output_histogram, width=0.4, alpha=0.5, color='g', label='Output')
            plt.title("Input vs Output Histogram")
            plt.xlabel('Pixel Value')
            plt.ylabel('Frequency')
            plt.legend()
            plt.show()
            self.progressBar.setValue(0)

    def display_histogram(self, label, title):
        pixmap = label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            for y in range(height):
                for x in range(width):
                    r, g, b, _ = QtGui.QColor(image.pixel(x, y)).getRgb()
                    gray_value = int((r + g + b) / 3)
                    grayscale_image[y][x] = gray_value

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            # Menghitung histogram
            histogram = np.zeros(256, dtype=np.uint32)
            for y in range(height):
                for x in range(width):
                    gray_value = grayscale_image[y][x]
                    histogram[gray_value] += 1

            # Menampilkan histogram dalam bentuk grafik batang
            plt.figure()
            plt.bar(range(256), histogram, width=1.0, color='b')
            plt.title(title)
            plt.xlabel('Pixel Value')
            plt.ylabel('Frequency')
            plt.show()
            self.progressBar.setValue(0)

    def display_input_histogram(self):
        self.display_histogram(self.label, "Input Histogram")

    def display_output_histogram(self):
        self.display_histogram(self.label_2, "Output Histogram")

    def histogram_equalization(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            # Menghitung histogram
            histogram = [0] * 256
            for y in range(height):
                for x in range(width):
                    r, g, b, _ = QtGui.QColor(image.pixel(x, y)).getRgb()
                    gray_value = int((r + g + b) / 3)
                    grayscale_image[y][x] = gray_value
                    histogram[gray_value] += 1

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            # Menghitung cumulative histogram
            cumulative_histogram = [sum(histogram[:i+1]) for i in range(256)]

            # Normalisasi cumulative histogram
            max_pixel_value = width * height
            normalized_cumulative_histogram = [(cumulative_histogram[i] / max_pixel_value) * 255 for i in range(256)]

            # Menerapkan equalization pada citra
            equalized_image = np.zeros((height, width), dtype=np.uint8)
            for y in range(height):
                for x in range(width):
                    equalized_image[y][x] = int(normalized_cumulative_histogram[grayscale_image[y][x]])

            equalized_qimage = QtGui.QImage(equalized_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
            equalized_pixmap = QtGui.QPixmap.fromImage(equalized_qimage)
            self.label_2.setPixmap(equalized_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def fuzzy_histogram_equalization_grayscale(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0

            input_data = np.zeros((height, width), dtype=np.uint8)
            for y in range(height):
                for x in range(width):
                    color = QColor(image.pixel(x, y))

                    val = int(0.3 * color.red() + 0.59 * color.green() + 0.11 * color.blue())
                    input_data[y, x] = val

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            output_image = QImage(input_data.data, width, height, width, QImage.Format_Grayscale8)
            self.label_2.setPixmap(QPixmap.fromImage(output_image))
            self.progressBar.setValue(0)

    def fuzzy_histogram_equalization_rgb(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0

            input_data = np.zeros((height, width, 3), dtype=np.uint8)
            for y in range(height):
                for x in range(width):
                    color = QColor(image.pixel(x, y))
                    input_data[y, x, 0] = color.red()
                    input_data[y, x, 1] = color.green()
                    input_data[y, x, 2] = color.blue()

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            output_data = np.zeros_like(input_data)
            for i in range(3):  
                for y in range(height):
                    for x in range(width):
                        val = input_data[y, x, i]
                        if val < 128:
                            output_data[y, x, i] = int(2 * val ** 2 / 255.0)
                        else:
                            output_data[y, x, i] = int(255 - 2 * (255 - val) ** 2 / 255.0)

            output_image = QImage(output_data.data, width, height, width * 3, QImage.Format_RGB888)
            self.label_2.setPixmap(QPixmap.fromImage(output_image))
            self.progressBar.setValue(0)

    def uniform_scaling(self):
        if hasattr(self, 'image'):
            if not self.label.pixmap():
                return

            # Menampilkan dialog untuk memasukkan faktor scaling
            factor, ok = QtWidgets.QInputDialog.getDouble(None, "Uniform Scaling", "Enter scaling factor (e.g., 2.0 for doubling the size):", 1.0, 0.01, 10.0)

            if ok:
                # Mendapatkan pixmap yang akan diubah skala
                pixmap = self.label.pixmap()

                # Mendapatkan ukuran asli pixmap
                original_size = pixmap.size()

                # Menghitung ukuran baru setelah scaling
                new_size = QtCore.QSize(int(original_size.width() * factor), int(original_size.height() * factor))

                # Melakukan scaling pada pixmap
                scaled_pixmap = pixmap.scaled(new_size, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)

                # Menampilkan hasil scaling di label_2
                self.label_2.setPixmap(scaled_pixmap)
                self.label_2.setScaledContents(False)
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)

    def non_uniform_scaling(self):
        if hasattr(self, 'image'):
            if not self.label.pixmap():
                return

            # Menampilkan dialog untuk memasukkan faktor scaling horizontal dan vertikal
            x_factor, ok1 = QtWidgets.QInputDialog.getDouble(None, "Non-Uniform Scaling", "Enter horizontal scaling factor (e.g., 2.0 for doubling the width):", 1.0, 0.01, 10.0)
            y_factor, ok2 = QtWidgets.QInputDialog.getDouble(None, "Non-Uniform Scaling", "Enter vertical scaling factor (e.g., 2.0 for doubling the height):", 1.0, 0.01, 10.0)

            if ok1 and ok2:
                # Mendapatkan pixmap yang akan diubah skala
                pixmap = self.label.pixmap()

                # Mendapatkan ukuran asli pixmap
                original_size = pixmap.size()

                # Menghitung ukuran baru setelah scaling
                new_width = int(original_size.width() * x_factor)
                new_height = int(original_size.height() * y_factor)
                new_size = QtCore.QSize(new_width, new_height)

                # Melakukan scaling pada pixmap
                scaled_pixmap = pixmap.scaled(new_size, QtCore.Qt.IgnoreAspectRatio, QtCore.Qt.SmoothTransformation)

                # Menampilkan hasil scaling di label_2
                self.label_2.setPixmap(scaled_pixmap)
                self.label_2.setScaledContents(False)
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)

    def crop_image(self):
        if hasattr(self, 'image'):
            if not self.label.pixmap():
                return

            # Menampilkan dialog untuk memasukkan koordinat crop
            x1, ok1 = QtWidgets.QInputDialog.getInt(None, "Crop Image", "Enter x-coordinate of top-left corner:", 0, 0, self.image.width() - 1)
            y1, ok2 = QtWidgets.QInputDialog.getInt(None, "Crop Image", "Enter y-coordinate of top-left corner:", 0, 0, self.image.height() - 1)
            x2, ok3 = QtWidgets.QInputDialog.getInt(None, "Crop Image", "Enter x-coordinate of bottom-right corner:", self.image.width() - 1, 0, self.image.width() - 1)
            y2, ok4 = QtWidgets.QInputDialog.getInt(None, "Crop Image", "Enter y-coordinate of bottom-right corner:", self.image.height() - 1, 0, self.image.height() - 1)

            if ok1 and ok2 and ok3 and ok4:
                # Menyusun batas crop
                left = min(x1, x2)
                right = max(x1, x2)
                top = min(y1, y2)
                bottom = max(y1, y2)

                # Mendapatkan pixmap yang akan di-crop
                pixmap = self.label.pixmap()

                # Mendapatkan bagian yang di-crop dari pixmap
                cropped_pixmap = pixmap.copy(left, top, right - left, bottom - top)

                # Menampilkan hasil crop di label_2
                self.label_2.setPixmap(cropped_pixmap)
                self.label_2.setAlignment(QtCore.Qt.AlignCenter)

    def reduce_bit_depth(self, pixmap, num_bits):
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0  

            max_value = (2 ** num_bits) - 1
            step = 255 / max_value

            reduced_image = QImage(width, height, QImage.Format_RGBA8888)

            for y in range(height):
                for x in range(width):
                    r, g, b, a = QtGui.QColor(image.pixel(x, y)).getRgb()

                    # Menghitung nilai baru untuk setiap komponen warna
                    new_r = int(r / step) * step
                    new_g = int(g / step) * step
                    new_b = int(b / step) * step

                    reduced_image.setPixelColor(x, y, QtGui.QColor(int(new_r), int(new_g), int(new_b), a))  # Mengubah nilai menjadi integer

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            reduced_pixmap = QPixmap.fromImage(reduced_image)
            self.label_2.setPixmap(reduced_pixmap)
            self.label_2.setAlignment(Qt.AlignCenter)
            self.progressBar.setValue(0)

    def reduce_to_1_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 1)

    def reduce_to_2_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 2)

    def reduce_to_3_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 3)

    def reduce_to_4_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 4)

    def reduce_to_5_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 5)

    def reduce_to_6_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 6)

    def reduce_to_7_bit(self):
        self.reduce_bit_depth(self.label.pixmap(), 7)

    def open_aritmatika(self):
            subprocess.run(["python", "Aritmatika.py"])

    def rotate_image(self):
        if hasattr(self, 'image'):
            rotation_angle, ok = QtWidgets.QInputDialog.getInt(None, "Rotate Image", "Enter rotation angle (degrees):", 0, -360, 360)
            if ok:
                pixmap = self.label.pixmap()
                if pixmap:
                    rotated_pixmap = pixmap.transformed(QtGui.QTransform().rotate(rotation_angle))
                    
                    self.rotate_window = RotateImageWindow(rotated_pixmap)
                    self.rotate_window.show()

    def apply_brightness_contrast(self, brightness, contrast):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            adjusted_image = np.zeros((height, width, 4), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0

            for y in range(height):
                for x in range(width):
                    r, g, b, a = QtGui.QColor(image.pixel(x, y)).getRgb()

                    adjusted_r = min(max(r + brightness, 0), 255)
                    adjusted_g = min(max(g + brightness, 0), 255)
                    adjusted_b = min(max(b + brightness, 0), 255)

                    adjusted_r = min(max(((adjusted_r - 127) * contrast) + 127, 0), 255)
                    adjusted_g = min(max(((adjusted_g - 127) * contrast) + 127, 0), 255)
                    adjusted_b = min(max(((adjusted_b - 127) * contrast) + 127, 0), 255)

                    adjusted_image[y][x] = [adjusted_r, adjusted_g, adjusted_b, a]

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            adjusted_qimage = QtGui.QImage(adjusted_image.data, width, height, width * 4, QtGui.QImage.Format_RGBA8888)

            adjusted_pixmap = QtGui.QPixmap.fromImage(adjusted_qimage)
            self.label_2.setPixmap(adjusted_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def open_brightness_contrast_dialog(self):
        brightness, ok1 = QtWidgets.QInputDialog.getInt(None, "Brightness", "Enter brightness (-255 to 255):", 0, -255, 255)
        contrast, ok2 = QtWidgets.QInputDialog.getDouble(None, "Contrast", "Enter contrast (0.01 to 4.0):", 1.0, 0.01, 4.0)

        if ok1 and ok2:
            self.apply_brightness_contrast(brightness, contrast)

    def save_image(self):
            pixmap = self.label_2.pixmap()
            if pixmap:
                file_path, _ = QFileDialog.getSaveFileName(None, "Save Image File", "", "Images (*.png *.jpg *.bmp);;All Files (*)")
                if file_path:
                    pixmap.save(file_path)

    def rgb_to_grayscale_average(self, pixmap):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0  

            for y in range(height):
                for x in range(width):
                    r, g, b, _ = QtGui.QColor(image.pixel(x, y)).getRgb()
                    
                    gray_value = int((r + g + b) / 3)
                    
                    grayscale_image[y][x] = gray_value

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            grayscale_qimage = QtGui.QImage(grayscale_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
            
            grayscale_pixmap = QtGui.QPixmap.fromImage(grayscale_qimage)
            self.label_2.setPixmap(grayscale_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def rgb_to_grayscale_lightness(self, pixmap):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0

            for y in range(height):
                for x in range(width):
                    r, g, b, _ = QtGui.QColor(image.pixel(x, y)).getRgb()
                    
                    lightness_value = int((max(r, g, b) + min(r, g, b)) / 2)
                    
                    grayscale_image[y][x] = lightness_value

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            grayscale_qimage = QtGui.QImage(grayscale_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
            
            grayscale_pixmap = QtGui.QPixmap.fromImage(grayscale_qimage)
            self.label_2.setPixmap(grayscale_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def rgb_to_grayscale_luminance(self, pixmap):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            grayscale_image = np.zeros((height, width), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0  

            for y in range(height):
                for x in range(width):
                    r, g, b, _ = QtGui.QColor(image.pixel(x, y)).getRgb()
                    
                    luminance_value = int(0.299 * r + 0.587 * g + 0.114 * b)
                    
                    grayscale_image[y][x] = luminance_value

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            grayscale_qimage = QtGui.QImage(grayscale_image.data, width, height, width, QtGui.QImage.Format_Grayscale8)
            
            grayscale_pixmap = QtGui.QPixmap.fromImage(grayscale_qimage)
            self.label_2.setPixmap(grayscale_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def invert_colors(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            inverted_image = np.zeros((height, width, 4), dtype=np.uint8)

            total_pixels = width * height
            processed_pixels = 0 

            for y in range(height):
                for x in range(width):
                    r, g, b, a = QtGui.QColor(image.pixel(x, y)).getRgb()
                    
                    inverted_r = 255 - r
                    inverted_g = 255 - g
                    inverted_b = 255 - b
                    
                    inverted_image[y][x] = [inverted_r, inverted_g, inverted_b, a]

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)

            inverted_qimage = QtGui.QImage(inverted_image.data, width, height, width * 4, QtGui.QImage.Format_RGBA8888)
            
            inverted_pixmap = QtGui.QPixmap.fromImage(inverted_qimage)
            self.label_2.setPixmap(inverted_pixmap)
            self.label_2.setAlignment(QtCore.Qt.AlignCenter)
            self.progressBar.setValue(0)

    def flip_horizontal(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0  

            flipped_image = QImage(width, height, QImage.Format_RGBA8888)

            for y in range(height):
                for x in range(width):
                    pixel_color = QtGui.QColor(image.pixel(x, y))
                    flipped_image.setPixelColor(width - 1 - x, y, pixel_color)

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)        

            flipped_pixmap = QPixmap.fromImage(flipped_image)
            self.label_2.setPixmap(flipped_pixmap)
            self.label_2.setAlignment(Qt.AlignCenter)
            self.progressBar.setValue(0)

    def flip_vertical(self):
        pixmap = self.label.pixmap()
        if pixmap:
            image = pixmap.toImage()
            width = image.width()
            height = image.height()

            total_pixels = width * height
            processed_pixels = 0  

            flipped_image = QImage(width, height, QImage.Format_RGBA8888)

            for y in range(height):
                for x in range(width):
                    pixel_color = QtGui.QColor(image.pixel(x, y))
                    flipped_image.setPixelColor(x, height - 1 - y, pixel_color)

                    processed_pixels += 1
                    progress_percent = int((processed_pixels / total_pixels) * 100)
                    self.progressBar.setValue(progress_percent)  

            flipped_pixmap = QPixmap.fromImage(flipped_image)
            self.label_2.setPixmap(flipped_pixmap)
            self.label_2.setAlignment(Qt.AlignCenter)
            self.progressBar.setValue(0)

    def region_of_interest(self):
        pixmap = self.label.pixmap()
        if pixmap:
            self.new_window = NewWindow(pixmap)
            self.new_window.roi_selected.connect(self.display_roi)
            self.new_window.show()

    def display_roi(self, roi_pixmap):
        self.label_2.setPixmap(roi_pixmap)
        self.new_window.close()

class RotateImageWindow(QMainWindow):
    def __init__(self, rotated_pixmap):
        super().__init__()
        self.setWindowTitle("Rotated Image")
        self.setWindowState(QtCore.Qt.WindowFullScreen) 

        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)

        layout = QVBoxLayout(central_widget)

        scroll_area = QScrollArea()
        layout.addWidget(scroll_area)

        self.rotated_label = QLabel()
        scroll_area.setWidget(self.rotated_label)
        scroll_area.setWidgetResizable(True) 

        self.rotated_label.setPixmap(rotated_pixmap)
        self.rotated_label.setAlignment(QtCore.Qt.AlignCenter)
  
        save_button = QPushButton("Simpan")
        layout.addWidget(save_button)
        save_button.clicked.connect(self.save_image)

        close_button = QPushButton("Close")
        layout.addWidget(close_button)
        close_button.clicked.connect(self.close)

    def closeEvent(self, event):
        self.rotated_label.clear()
        event.accept()

    def save_image(self):
        pixmap = self.rotated_label.pixmap()
        if pixmap:
            file_path, _ = QFileDialog.getSaveFileName(None, "Save Image File", "", "Images (*.png *.jpg *.bmp);;All Files (*)")
            if file_path:
                pixmap.save(file_path)

class NewWindow(QMainWindow):
    roi_selected = QtCore.pyqtSignal(QPixmap)

    def __init__(self, original_pixmap):
        super().__init__()

        self.setWindowTitle("Region of Interest")
        self.setGeometry(100, 100, original_pixmap.width(), original_pixmap.height())

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)

        self.layout = QVBoxLayout(self.central_widget)

        # Menggunakan QGraphicsView dan QGraphicsScene untuk menampilkan gambar
        self.view = QGraphicsView()
        self.layout.addWidget(self.view)

        self.scene = QGraphicsScene()
        self.view.setScene(self.scene)

        self.original_pixmap_item = QGraphicsPixmapItem(original_pixmap)
        self.scene.addItem(self.original_pixmap_item)

        self.selection_rect = QRectF()
        self.is_selecting = False
        self.selection_polygon = QPolygonF()
        self.selection_item = None

        self.view.mousePressEvent = self.mousePressEvent
        self.view.mouseMoveEvent = self.mouseMoveEvent
        self.view.mouseReleaseEvent = self.mouseReleaseEvent

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_selecting = True
            self.selection_rect.setTopLeft(event.pos())
            self.selection_rect.setBottomRight(event.pos())

    def mouseMoveEvent(self, event):
        if self.is_selecting:
            self.selection_rect.setBottomRight(event.pos())
            self.selection_polygon = QPolygonF([
                self.selection_rect.topLeft(),
                self.selection_rect.topRight(),
                self.selection_rect.bottomRight(),
                self.selection_rect.bottomLeft()
            ])
            if self.selection_item is not None:
                self.scene.removeItem(self.selection_item)
            self.selection_item = self.scene.addPolygon(self.selection_polygon, QPen(QColor(255, 0, 0)))

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_selecting = False
            selected_area = self.original_pixmap_item.pixmap().copy(self.selection_rect.toRect())
            selected_pixmap = QPixmap(selected_area.size())
            selected_pixmap.fill(Qt.white)
            painter = QPainter(selected_pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setRenderHint(QPainter.SmoothPixmapTransform)
            painter.setRenderHint(QPainter.HighQualityAntialiasing)
            painter.setRenderHint(QPainter.TextAntialiasing)
            painter.setPen(QPen(QColor(0, 0, 0), 2))
            painter.drawPixmap(QPoint(0, 0), selected_area)
            painter.end()
            self.roi_selected.emit(selected_pixmap)

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()

    screen = QtWidgets.QApplication.desktop().screenGeometry()
    size = MainWindow.geometry()
    MainWindow.move((screen.width() - size.width()) // 2, (screen.height() - size.height()) // 5)

    sys.exit(app.exec_())
